module  ghost1 ( input Reset, frame_clk, Over,
					input [7:0] keycode,
					input [9:0]   DrawX, DrawY,
					input [9:0] Ghost_X_Start, Ghost_Y_Start,
               output [9:0]  GhostX, GhostY, GhostS );
    
    logic [9:0] Ghost_X_Pos, Ghost_X_Motion, Ghost_Y_Pos, Ghost_Y_Motion, GhostSize;
    logic [9:0] Ghost_X_Pos_in, Ghost_X_Motion_in, Ghost_Y_Pos_in, Ghost_Y_Motion_in;
	 logic [7:0] prevkey;
	 logic Up, Right, Left, Down, RightUp, RightDown, LeftUp, LeftDown, RightUp1, RightDown1, LeftUp1, LeftDown1;
	 logic Xmove, Ymove;
    assign Ghost_X_Center= Ghost_X_Start;  // Center position on the X axis
    assign Ghost_Y_Center= Ghost_Y_Start;  // Center position on the Y axis
    parameter [9:0] Ghost_X_Min=0;       // Leftmost point on the X axis
    parameter [9:0] Ghost_X_Max=639;     // Rightmost point on the X axis
    parameter [9:0] Ghost_Y_Min=0;       // Topmost point on the Y axis
    parameter [9:0] Ghost_Y_Max=479;     // Bottommost point on the Y axis
    parameter [9:0] Ghost_X_Step=1;      // Step size on the X axis
    parameter [9:0] Ghost_Y_Step=1;      // Step size on the Y axis

    assign Ghost_Size = 16;  // assigns the value 4 as a 10-digit binary number, ie "0000000100"
	 always_ff @ (posedge Reset, posedge frame_clk, posedge Over)
    begin
        if (Over)
        begin
            prevkey<= 8'h00;
        end
		  else if (Reset)
        begin
            prevkey<= 8'h00;
        end
        else 
        begin
            //if((keycode==8'h1A)||(keycode==8'h16)||(keycode==8'h04)||(keycode==8'h07)) begin  prevkey <= keycode;  end  
        end
    end
    always_ff @ (posedge Reset, posedge Over, posedge frame_clk )
	 begin: Move_Ghost
		if (Reset)  // Asynchronous Reset
        begin 
            Ghost_Y_Motion <= 10'd0; //Ghost_Y_Step;
				Ghost_X_Motion <= 10'd0; //Ghost_X_Step;
				Ghost_Y_Pos <= Ghost_Y_Center;
				Ghost_X_Pos <= Ghost_X_Center;
        end
		else if (Over)
        begin 
            Ghost_Y_Motion <= 10'd0; //Ghost_Y_Step;
				Ghost_X_Motion <= 10'd0; //Ghost_X_Step;
				Ghost_Y_Pos <= Ghost_Y_Center;
				Ghost_X_Pos <= Ghost_X_Center;
        end		    
      else 
        begin 
            Ghost_X_Pos <= Ghost_X_Pos_in;
            Ghost_Y_Pos <= Ghost_Y_Pos_in;
            Ghost_X_Motion <= Ghost_X_Motion_in;
            Ghost_Y_Motion <= Ghost_Y_Motion_in;
		   end
		end
		
		
	 always_comb	  
	 begin
				Ghost_X_Motion_in = Ghost_X_Motion;
				Ghost_Y_Motion_in = Ghost_Y_Motion;
				unique case (keycode)
					8'h04 : //A
					begin
								if (Left)
									begin
										if (Ghost_Y_Motion == Ghost_Y_Step)
											begin
												if (Down)
													begin
														Ghost_X_Motion_in = 0;
														Ghost_Y_Motion_in = 0;   
													end
												else
													begin								
														Ghost_X_Motion_in = 0;
														Ghost_Y_Motion_in = Ghost_Y_Step;
													end											
											end
										else if (Ghost_Y_Motion == (~(Ghost_Y_Step) + 1'b1))
											begin
												if (Up)
													begin
														Ghost_X_Motion_in = 0;
														Ghost_Y_Motion_in = 0;   
													end
												else
													begin								
														Ghost_X_Motion_in = 0;
														Ghost_Y_Motion_in = (~(Ghost_Y_Step) + 1'b1);
													end
											end
										else
											begin
												Ghost_X_Motion_in = 0;
												Ghost_Y_Motion_in = 0;
											end
									end
								else
									begin
										Ghost_X_Motion_in = (~(Ghost_X_Step) + 1'b1);//A
										Ghost_Y_Motion_in = 0;
									end
							  end
					        
					8'h07 : //D 
						begin   
								if (Right)
									begin
										if (Ghost_Y_Motion == Ghost_Y_Step)
											begin
												if (Down)
													begin
														Ghost_X_Motion_in = 0;
														Ghost_Y_Motion_in = 0;   
													end
												else
													begin								
														Ghost_X_Motion_in = 0;
														Ghost_Y_Motion_in = Ghost_Y_Step;
													end											
											end
										else if (Ghost_Y_Motion == (~(Ghost_Y_Step) + 1'b1))
											begin
												if (Up)
													begin
														Ghost_X_Motion_in = 0;
														Ghost_Y_Motion_in = 0;   
													end
												else
													begin								
														Ghost_X_Motion_in = 0;
														Ghost_Y_Motion_in = (~(Ghost_Y_Step) + 1'b1);
													end
											end
										else
											begin
												Ghost_X_Motion_in = 0;
												Ghost_Y_Motion_in = 0;
											end
									end
								else
									begin								
										Ghost_X_Motion_in = Ghost_X_Step;//D
										Ghost_Y_Motion_in = 0;
									end
							  end

							  
					8'h16 : //S
						begin  
								if (Down)
									begin
										if (Ghost_X_Motion == Ghost_X_Step)
											begin
												if (Right)
													begin
														Ghost_X_Motion_in = 0;
														Ghost_Y_Motion_in = 0;   
													end
												else
													begin								
														Ghost_X_Motion_in = Ghost_X_Step;
														Ghost_Y_Motion_in = 0;
													end											
											end
										else if (Ghost_X_Motion == (~(Ghost_X_Step) + 1'b1))
											begin
												if (Left)
													begin
														Ghost_X_Motion_in = 0;
														Ghost_Y_Motion_in = 0;   
													end
												else
													begin								
														Ghost_X_Motion_in = (~(Ghost_X_Step) + 1'b1);
														Ghost_Y_Motion_in = 0;
													end
											end
										else
											begin
												Ghost_X_Motion_in = 0;
												Ghost_Y_Motion_in = 0;
											end
									end
								else
									begin
										Ghost_Y_Motion_in = Ghost_Y_Step;//S
										Ghost_X_Motion_in = 0;
									end
							 end
							  
					8'h1A :
						begin
								if (Up)
									begin
										if (Ghost_X_Motion == Ghost_X_Step)
											begin
												if (Right)
													begin
														Ghost_X_Motion_in = 0;
														Ghost_Y_Motion_in = 0;   
													end
												else
													begin								
														Ghost_X_Motion_in = Ghost_X_Step;
														Ghost_Y_Motion_in = 0;
													end											
											end
										else if (Ghost_X_Motion == (~(Ghost_X_Step) + 1'b1))
											begin
												if (Left)
													begin
														Ghost_X_Motion_in = 0;
														Ghost_Y_Motion_in = 0;   
													end
												else
													begin								
														Ghost_X_Motion_in = (~(Ghost_X_Step) + 1'b1);
														Ghost_Y_Motion_in = 0;
													end
											end
										else
											begin
												Ghost_X_Motion_in = 0;
												Ghost_Y_Motion_in = 0;
											end
									end
								else
									begin
										Ghost_Y_Motion_in = (~(Ghost_Y_Step) + 1'b1);//W
										Ghost_X_Motion_in = 0;
									end
							 end	  
					default:
					begin
					
						if ((Ghost_Y_Motion == (~(Ghost_Y_Step) + 1'b1)) && Up)
							begin
										Ghost_X_Motion_in = 0;
										Ghost_Y_Motion_in = 0;
							end
						else if ((Ghost_Y_Motion == Ghost_Y_Step) && Down)
							begin
										Ghost_X_Motion_in = 0;
										Ghost_Y_Motion_in = 0;
							end
						else if ((Ghost_X_Motion == (~(Ghost_X_Step) + 1'b1)) && Left)
							begin
										Ghost_X_Motion_in = 0;
										Ghost_Y_Motion_in = 0;
							end
						else if ((Ghost_X_Motion == Ghost_X_Step) && Right)
							begin
										Ghost_X_Motion_in = 0;
										Ghost_Y_Motion_in = 0;
							end
						else
							begin
										Ghost_X_Motion_in = Ghost_X_Motion;
										Ghost_Y_Motion_in = Ghost_Y_Motion;
							end
					end
			   endcase
				 
				 Ghost_Y_Pos_in = (Ghost_Y_Pos + Ghost_Y_Motion_in);  // Update Ghost position
				 Ghost_X_Pos_in = (Ghost_X_Pos + Ghost_X_Motion_in);
      
			
		end         
    assign GhostX = Ghost_X_Pos;
    assign GhostY = Ghost_Y_Pos;
    assign GhostS = GhostSize;
	 ValidMoveUp validup(.GhostX(Ghost_X_Pos),.GhostY(Ghost_Y_Pos),.Up(Up));
	 ValidMoveDown validdown(.GhostX(Ghost_X_Pos),.GhostY(Ghost_Y_Pos),.Down(Down));
	 ValidMoveLeft validleft(.GhostX(Ghost_X_Pos),.GhostY(Ghost_Y_Pos),.Left(Left));
	 ValidMoveRight validright(.GhostX(Ghost_X_Pos),.GhostY(Ghost_Y_Pos),.Right(Right));
endmodule